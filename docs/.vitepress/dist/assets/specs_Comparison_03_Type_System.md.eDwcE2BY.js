import{_ as e,c as s,o as i,aj as a}from"./chunks/framework.CSCBGoZg.js";const g=JSON.parse('{"title":"Type System Comparison","description":"","frontmatter":{},"headers":[],"relativePath":"specs/Comparison/03_Type_System.md","filePath":"specs/Comparison/03_Type_System.md"}'),l={name:"specs/Comparison/03_Type_System.md"};function n(d,t,o,r,h,p){return i(),s("div",null,[...t[0]||(t[0]=[a(`<h1 id="type-system-comparison" tabindex="-1">Type System Comparison <a class="header-anchor" href="#type-system-comparison" aria-label="Permalink to “Type System Comparison”">​</a></h1><p>This document compares Vex&#39;s type system with Go, Rust, C, and C++.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Feature</th><th style="text-align:left;">Vex</th><th style="text-align:left;">Go</th><th style="text-align:left;">Rust</th><th style="text-align:left;">C</th><th style="text-align:left;">C++</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Strong Typing</strong></td><td style="text-align:left;">Yes</td><td style="text-align:left;">Yes</td><td style="text-align:left;">Yes</td><td style="text-align:left;">Weak</td><td style="text-align:left;">Moderate</td></tr><tr><td style="text-align:left;"><strong>Type Inference</strong></td><td style="text-align:left;">Function body local</td><td style="text-align:left;">Function body local</td><td style="text-align:left;">Function body local</td><td style="text-align:left;"><code>auto</code> (C23)</td><td style="text-align:left;"><code>auto</code></td></tr><tr><td style="text-align:left;"><strong>Structs</strong></td><td style="text-align:left;"><code>struct</code></td><td style="text-align:left;"><code>struct</code></td><td style="text-align:left;"><code>struct</code></td><td style="text-align:left;"><code>struct</code></td><td style="text-align:left;"><code>class</code> / <code>struct</code></td></tr><tr><td style="text-align:left;"><strong>Methods</strong></td><td style="text-align:left;">External (<code>fn (s: &amp;T)</code>)</td><td style="text-align:left;">External (<code>func (s *T)</code>)</td><td style="text-align:left;">Implement block (<code>impl T</code>)</td><td style="text-align:left;">N/A</td><td style="text-align:left;">Internal (Class body)</td></tr><tr><td style="text-align:left;"><strong>Interfaces</strong></td><td style="text-align:left;"><code>contract</code></td><td style="text-align:left;"><code>interface</code></td><td style="text-align:left;"><code>trait</code></td><td style="text-align:left;">N/A</td><td style="text-align:left;">Abstract Class</td></tr><tr><td style="text-align:left;"><strong>Generics</strong></td><td style="text-align:left;">Yes (<code>&lt;T&gt;</code>)</td><td style="text-align:left;">Yes (<code>[T]</code>)</td><td style="text-align:left;">Yes (<code>&lt;T&gt;</code>)</td><td style="text-align:left;">No (<code>void*</code>)</td><td style="text-align:left;">Templates (<code>&lt;T&gt;</code>)</td></tr><tr><td style="text-align:left;"><strong>Enums</strong></td><td style="text-align:left;">Sum Types (Data variants)</td><td style="text-align:left;">Integer constants</td><td style="text-align:left;">Sum Types</td><td style="text-align:left;">Integers</td><td style="text-align:left;">Integers / <code>enum class</code></td></tr><tr><td style="text-align:left;"><strong>Union Types</strong></td><td style="text-align:left;"><code>TypeA | TypeB</code></td><td style="text-align:left;">No</td><td style="text-align:left;">No (Use Enums)</td><td style="text-align:left;"><code>union</code> (C-style)</td><td style="text-align:left;"><code>std::variant</code></td></tr><tr><td style="text-align:left;"><strong>Tuple</strong></td><td style="text-align:left;"><code>(A, B)</code></td><td style="text-align:left;">No</td><td style="text-align:left;"><code>(A, B)</code></td><td style="text-align:left;">N/A</td><td style="text-align:left;"><code>std::tuple</code></td></tr><tr><td style="text-align:left;"><strong>Aliasing</strong></td><td style="text-align:left;"><code>type Name = Type</code></td><td style="text-align:left;"><code>type Name Type</code></td><td style="text-align:left;"><code>type Name = Type</code></td><td style="text-align:left;"><code>typedef</code></td><td style="text-align:left;"><code>using</code></td></tr></tbody></table><h2 id="distinctive-features" tabindex="-1">Distinctive Features <a class="header-anchor" href="#distinctive-features" aria-label="Permalink to “Distinctive Features”">​</a></h2><h3 id="contracts-vs-traits-vs-interfaces" tabindex="-1">Contracts vs Traits vs Interfaces <a class="header-anchor" href="#contracts-vs-traits-vs-interfaces" aria-label="Permalink to “Contracts vs Traits vs Interfaces”">​</a></h3><ul><li><strong>Vex Contracts</strong>: Similar to Rust traits but allow for both static dispatch and dynamic usage (future). Uses <code>impl Contract</code> syntax on the struct definition line, unlike Rust&#39;s separate <code>impl Trait for Type</code> block.</li><li><strong>Go Interfaces</strong>: Implicit implementation. If methods match, it implements it.</li><li><strong>Rust Traits</strong>: Explicit implementation block.</li></ul><h3 id="enums" tabindex="-1">Enums <a class="header-anchor" href="#enums" aria-label="Permalink to “Enums”">​</a></h3><p>Vex Enums are true sum types, capable of holding data (like Rust).</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Quit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(string),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="method-syntax" tabindex="-1">Method Syntax <a class="header-anchor" href="#method-syntax" aria-label="Permalink to “Method Syntax”">​</a></h3><p>Vex adopts a hybrid &quot;Go-style&quot; definition for methods to keep structs simple data containers, but uses <code>let!</code> for mutability.</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Point</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">distance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Point!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">move</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span></code></pre></div>`,12)])])}const y=e(l,[["render",n]]);export{g as __pageData,y as default};
