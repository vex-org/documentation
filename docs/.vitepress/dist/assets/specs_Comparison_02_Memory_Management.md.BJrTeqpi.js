import{_ as e,c as l,o as a,aj as s}from"./chunks/framework.CSCBGoZg.js";const h=JSON.parse('{"title":"Memory Management Comparison","description":"","frontmatter":{},"headers":[],"relativePath":"specs/Comparison/02_Memory_Management.md","filePath":"specs/Comparison/02_Memory_Management.md"}'),i={name:"specs/Comparison/02_Memory_Management.md"};function n(d,t,o,r,c,g){return a(),l("div",null,[...t[0]||(t[0]=[s(`<h1 id="memory-management-comparison" tabindex="-1">Memory Management Comparison <a class="header-anchor" href="#memory-management-comparison" aria-label="Permalink to “Memory Management Comparison”">​</a></h1><p>This document compares Vex&#39;s memory management model with Go, Rust, C, and C++.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Feature</th><th style="text-align:left;">Vex</th><th style="text-align:left;">Go</th><th style="text-align:left;">Rust</th><th style="text-align:left;">C</th><th style="text-align:left;">C++</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Strategy</strong></td><td style="text-align:left;">Ownership &amp; Borrowing</td><td style="text-align:left;">Garbage Collection</td><td style="text-align:left;">Ownership &amp; Borrowing</td><td style="text-align:left;">Manual</td><td style="text-align:left;">Manual + RAII</td></tr><tr><td style="text-align:left;"><strong>Ownership</strong></td><td style="text-align:left;">Compile-time check (Move)</td><td style="text-align:left;">N/A</td><td style="text-align:left;">Compile-time check (Move)</td><td style="text-align:left;">N/A</td><td style="text-align:left;">Move semantics (std::move)</td></tr><tr><td style="text-align:left;"><strong>Reference (Immutable)</strong></td><td style="text-align:left;"><code>&amp;T</code></td><td style="text-align:left;">N/A (Pointers)</td><td style="text-align:left;"><code>&amp;T</code></td><td style="text-align:left;"><code>const T*</code></td><td style="text-align:left;"><code>const T&amp;</code></td></tr><tr><td style="text-align:left;"><strong>Reference (Mutable)</strong></td><td style="text-align:left;"><code>&amp;T!</code></td><td style="text-align:left;">N/A (Pointers)</td><td style="text-align:left;"><code>&amp;mut T</code></td><td style="text-align:left;"><code>T*</code></td><td style="text-align:left;"><code>T&amp;</code></td></tr><tr><td style="text-align:left;"><strong>Borrow Checking</strong></td><td style="text-align:left;">Yes (Single Writer OR Multiple Readers)</td><td style="text-align:left;">Runtime (Race detector only)</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td></tr><tr><td style="text-align:left;"><strong>Allocation</strong></td><td style="text-align:left;"><code>new(val)</code>, Stack default</td><td style="text-align:left;"><code>new</code>, <code>make</code> (Escape analysis)</td><td style="text-align:left;"><code>Box::new()</code>, Stack default</td><td style="text-align:left;"><code>malloc</code></td><td style="text-align:left;"><code>new</code></td></tr><tr><td style="text-align:left;"><strong>Deallocation</strong></td><td style="text-align:left;">Automatic (Drop contract)</td><td style="text-align:left;">GC</td><td style="text-align:left;">Automatic (Drop trait)</td><td style="text-align:left;"><code>free</code></td><td style="text-align:left;"><code>delete</code></td></tr><tr><td style="text-align:left;"><strong>Null Safety</strong></td><td style="text-align:left;"><code>Option&lt;T&gt;</code> (No null ref)</td><td style="text-align:left;"><code>nil</code> (Dangerous)</td><td style="text-align:left;"><code>Option&lt;T&gt;</code></td><td style="text-align:left;"><code>NULL</code></td><td style="text-align:left;"><code>nullptr</code></td></tr><tr><td style="text-align:left;"><strong>Raw Pointers</strong></td><td style="text-align:left;"><code>*T</code>, <code>*T!</code></td><td style="text-align:left;"><code>*T</code>, <code>uintptr</code></td><td style="text-align:left;"><code>*const T</code>, <code>*mut T</code></td><td style="text-align:left;"><code>T*</code></td><td style="text-align:left;"><code>T*</code></td></tr></tbody></table><h2 id="detailed-comparison" tabindex="-1">Detailed Comparison <a class="header-anchor" href="#detailed-comparison" aria-label="Permalink to “Detailed Comparison”">​</a></h2><h3 id="ownership" tabindex="-1">Ownership <a class="header-anchor" href="#ownership" aria-label="Permalink to “Ownership”">​</a></h3><p>Vex follows Rust&#39;s ownership model. Variables typically &quot;own&quot; their data. Assigning a value to another variable moves ownership (for non-Copy types), invalidating the previous variable.</p><h3 id="mutability" tabindex="-1">Mutability <a class="header-anchor" href="#mutability" aria-label="Permalink to “Mutability”">​</a></h3><ul><li><strong>Vex</strong>: Explicit marker <code>!</code> for mutable references (<code>&amp;i32!</code>).</li><li><strong>Rust</strong>: Keyword <code>mut</code> (<code>&amp;mut i32</code>).</li><li><strong>Go</strong>: Pointers are always mutable if you have the address.</li><li><strong>C/C++</strong>: <code>const</code> correctness is used, but opt-in.</li></ul><h3 id="cleanup" tabindex="-1">Cleanup <a class="header-anchor" href="#cleanup" aria-label="Permalink to “Cleanup”">​</a></h3><p>Vex uses the <code>Drop</code> contract (similar to Rust&#39;s <code>Drop</code> trait) to automatically clean up resources when a variable goes out of scope. It also supports Go-style <code>defer</code> for function-scoped cleanup.</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vex</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">defer file</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Go</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> file.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Rust</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Automatic via Drop</span></span></code></pre></div>`,13)])])}const y=e(i,[["render",n]]);export{h as __pageData,y as default};
