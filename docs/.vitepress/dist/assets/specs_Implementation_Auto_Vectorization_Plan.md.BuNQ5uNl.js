import{_ as a,c as i,o as t,aj as n}from"./chunks/framework.CSCBGoZg.js";const g=JSON.parse('{"title":"Auto Vectorization & HPC Roadmap","description":"","frontmatter":{},"headers":[],"relativePath":"specs/Implementation/Auto_Vectorization_Plan.md","filePath":"specs/Implementation/Auto_Vectorization_Plan.md"}'),o={name:"specs/Implementation/Auto_Vectorization_Plan.md"};function s(l,e,r,d,h,c){return t(),i("div",null,[...e[0]||(e[0]=[n(`<h1 id="auto-vectorization-hpc-roadmap" tabindex="-1">Auto Vectorization &amp; HPC Roadmap <a class="header-anchor" href="#auto-vectorization-hpc-roadmap" aria-label="Permalink to “Auto Vectorization &amp; HPC Roadmap”">​</a></h1><p><strong>Objective:</strong> Transform Vex into a native data-parallel language by leveraging LLVM&#39;s vectorizer and Vex&#39;s strict ownership model.</p><h2 id="_1-the-vex-advantage-safe-aliasing" tabindex="-1">1. The Vex Advantage: &quot;Safe Aliasing&quot; <a class="header-anchor" href="#_1-the-vex-advantage-safe-aliasing" aria-label="Permalink to “1. The Vex Advantage: &quot;Safe Aliasing&quot;”">​</a></h2><p>Unlike C/C++, Vex&#39;s Borrow Checker guarantees that mutable references (<code>&amp;mut [T]!</code>) are unique. This means we can emit <code>noalias</code> metadata with 100% confidence, unlocking aggressive optimizations that C++ compilers are too afraid to perform (due to potential pointer aliasing).</p><h2 id="phase-1-llvm-metadata-injection-immediate-win" tabindex="-1">Phase 1: LLVM Metadata Injection (Immediate Win) <a class="header-anchor" href="#phase-1-llvm-metadata-injection-immediate-win" aria-label="Permalink to “Phase 1: LLVM Metadata Injection (Immediate Win)”">​</a></h2><p>LLVM&#39;s loop vectorizer is powerful effectively if &quot;hinted&quot; correctly. We need to inject metadata into the back-edge branches of our loops.</p><h3 id="target-files" tabindex="-1">Target Files <a class="header-anchor" href="#target-files" aria-label="Permalink to “Target Files”">​</a></h3><ul><li><code>vex-compiler/src/codegen_ast/statements/loops/for_in_loop.rs</code><ul><li><code>compile_for_in_array_impl</code></li><li><code>compile_for_in_vec_impl</code></li></ul></li></ul><h3 id="implementation-detail" tabindex="-1">Implementation Detail <a class="header-anchor" href="#implementation-detail" aria-label="Permalink to “Implementation Detail”">​</a></h3><p>When building the branch instruction back to the loop condition (<code>br label %cond</code>), we append metadata:</p><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>!0 = !{!&quot;llvm.loop.vectorize.enable&quot;, i1 1}</span></span>
<span class="line"><span>!1 = !{!&quot;llvm.loop.unroll.enable&quot;, i1 1}</span></span>
<span class="line"><span>!2 = !{!&quot;llvm.loop.vectorize.width&quot;, i32 4} ; Optional hint</span></span></code></pre></div><p><strong>Action Plan:</strong></p><ol><li>Define a helper <code>add_loop_metadata</code> in <code>ASTCodeGen</code>.</li><li>Apply this to <code>Array</code> and <code>Vec</code> iterators.</li><li>Verify IR output contains the metadata.</li></ol><h2 id="phase-2-the-no-alias-guarantee" tabindex="-1">Phase 2: The &quot;No-Alias&quot; Guarantee <a class="header-anchor" href="#phase-2-the-no-alias-guarantee" aria-label="Permalink to “Phase 2: The &quot;No-Alias&quot; Guarantee”">​</a></h2><p>To allow the vectorizer to load/store multiple elements in parallel without fear of overlapping memory:</p><ol><li><strong>Scope Identifiers:</strong> Create a distinct <code>alias.scope</code> for the source and destination arrays in the loop.</li><li><strong>Instruction Tagging:</strong> Tag every <code>load</code> and <code>store</code> instruction in the loop body with: <ul><li><code>!noalias</code>: &quot;This pointer does not overlap with [other scope]&quot;</li><li><code>!alias.scope</code>: &quot;This pointer belongs to [this scope]&quot;</li></ul></li></ol><p>Since Vex ensures <code>A</code> and <code>B</code> do not overlap if mutably borrowed, this is safe.</p><h2 id="phase-3-runtime-dispatch-the-hybrid-model" tabindex="-1">Phase 3: Runtime Dispatch (The &quot;Hybrid&quot; Model) <a class="header-anchor" href="#phase-3-runtime-dispatch-the-hybrid-model" aria-label="Permalink to “Phase 3: Runtime Dispatch (The &quot;Hybrid&quot; Model)”">​</a></h2><p>Loops with unknown sizes (like <code>Vec&lt;T&gt;</code>) should not always be vectorized (setup overhead).</p><p><strong>Strategy:</strong> Compile two versions of the loop body (Scalar vs. Vectorized) and select at runtime.</p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Pseudocode generated by compiler</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vec</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 128</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Jump to Validated Vector Loop (AVX-512 / SPIR-V)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    call </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vector_loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vec)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Standard Scalar Loop</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    call </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scalar_loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vec)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="phase-4-spir-v-offloading-simt" tabindex="-1">Phase 4: SPIR-V Offloading (SIMT) <a class="header-anchor" href="#phase-4-spir-v-offloading-simt" aria-label="Permalink to “Phase 4: SPIR-V Offloading (SIMT)”">​</a></h2><p>For massive workloads (&gt;1M items), map the loop logic to a SPIR-V compute shader.</p><ol><li>Extract loop body into a separate function.</li><li>Transpile LLVM IR subset -&gt; SPIR-V.</li><li>Inject Vex Runtime call to dispatch to GPU.</li></ol><h2 id="phase-5-deep-llvm-hints-advanced" tabindex="-1">Phase 5: Deep LLVM Hints (Advanced) <a class="header-anchor" href="#phase-5-deep-llvm-hints-advanced" aria-label="Permalink to “Phase 5: Deep LLVM Hints (Advanced)”">​</a></h2><p>Beyond vectorization, Vex can exploit its strong type system to provide LLVM with &quot;Perfect Information&quot;.</p><h3 id="_1-branch-prediction-prof" tabindex="-1">1. Branch Prediction (<code>!prof</code>) <a class="header-anchor" href="#_1-branch-prediction-prof" aria-label="Permalink to “1. Branch Prediction (!prof)”">​</a></h3><p>Error handling in Vex (<code>Result.Err</code>) is typically the &quot;unlikely&quot; path.</p><ul><li><strong>Strategy:</strong> Tag <code>if</code> conditions checking for errors with <code>branch_weights</code> metadata favouring the &quot;happy path&quot;.</li><li><strong>Effect:</strong> CPU branch predictor stays hot on the main logic trace.</li></ul><h3 id="_2-invariant-loads-invariant-load" tabindex="-1">2. Invariant Loads (<code>!invariant.load</code>) <a class="header-anchor" href="#_2-invariant-loads-invariant-load" aria-label="Permalink to “2. Invariant Loads (!invariant.load)”">​</a></h3><p>Vex variables are immutable by default (<code>let</code>).</p><ul><li><strong>Strategy:</strong> Tag loads from immutable references with <code>!invariant.load</code>.</li><li><strong>Effect:</strong> LLVM can aggressively hoist these loads out of loops, knowing they will never change, even if there are function calls inside the loop.</li></ul><h3 id="_3-alignment-non-null-align-nonnull" tabindex="-1">3. Alignment &amp; Non-Null (<code>!align</code>, <code>!nonnull</code>) <a class="header-anchor" href="#_3-alignment-non-null-align-nonnull" aria-label="Permalink to “3. Alignment &amp; Non-Null (!align, !nonnull)”">​</a></h3><p>Vex references (<code>&amp;T</code>) are strictly non-null and properly aligned.</p><ul><li><strong>Strategy:</strong> Attach <code>!nonnull</code> and <code>!align</code> metadata to every load/store of a reference type.</li><li><strong>Effect:</strong> Enables &quot;aligned vector moves&quot; (simpler assembly instructions) and removes redundant null checks.</li></ul><h3 id="_4-fast-math-context-dependent" tabindex="-1">4. Fast Math (Context Dependent) <a class="header-anchor" href="#_4-fast-math-context-dependent" aria-label="Permalink to “4. Fast Math (Context Dependent)”">​</a></h3><p>Inside <code>fn</code> or explicitly marked blocks, we can enable &quot;Fast Math&quot; flags (<code>nnan</code>, <code>nsz</code>, <code>arcp</code>).</p><ul><li><strong>Effect:</strong> 10-20% speedup on floating point heavy ML workloads by ignoring NaN corner cases and allowing algebraic re-association.</li></ul><h2 id="next-steps-immediate" tabindex="-1">Next Steps (Immediate) <a class="header-anchor" href="#next-steps-immediate" aria-label="Permalink to “Next Steps (Immediate)”">​</a></h2><p>Start with <strong>Phase 1 (Loop Metadata)</strong> and <strong>Phase 5.3 (Alignment/NonNull)</strong> as they yield the highest ROI with the lowest risk.</p>`,40)])])}const m=a(o,[["render",s]]);export{g as __pageData,m as default};
