import{_ as t,c as i,o as a,aj as e}from"./chunks/framework.CSCBGoZg.js";const g=JSON.parse('{"title":"Concurrency Comparison","description":"","frontmatter":{},"headers":[],"relativePath":"specs/Comparison/04_Concurrency.md","filePath":"specs/Comparison/04_Concurrency.md"}'),l={name:"specs/Comparison/04_Concurrency.md"};function n(h,s,r,k,d,p){return a(),i("div",null,[...s[0]||(s[0]=[e(`<h1 id="concurrency-comparison" tabindex="-1">Concurrency Comparison <a class="header-anchor" href="#concurrency-comparison" aria-label="Permalink to “Concurrency Comparison”">​</a></h1><p>This document compares Vex&#39;s concurrency and parallelism model with Go, Rust, C, and C++.</p><table tabindex="0"><thead><tr><th style="text-align:left;">Feature</th><th style="text-align:left;">Vex</th><th style="text-align:left;">Go</th><th style="text-align:left;">Rust</th><th style="text-align:left;">C</th><th style="text-align:left;">C++</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Paradigm</strong></td><td style="text-align:left;">CSP + Async/Await + <strong>Data Parallel</strong></td><td style="text-align:left;">CSP (Blocking)</td><td style="text-align:left;">Async/Await + Threads</td><td style="text-align:left;">OS Threads</td><td style="text-align:left;">OS Threads + Async</td></tr><tr><td style="text-align:left;"><strong>Lightweight Threads</strong></td><td style="text-align:left;"><code>go</code> routines (M:N)</td><td style="text-align:left;"><code>go</code> routines (M:N)</td><td style="text-align:left;">No (OS threads standard)</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td></tr><tr><td style="text-align:left;"><strong>Async Function</strong></td><td style="text-align:left;"><code>async fn</code></td><td style="text-align:left;">No</td><td style="text-align:left;"><code>async fn</code></td><td style="text-align:left;">No</td><td style="text-align:left;"><code>co_await</code> (C++20)</td></tr><tr><td style="text-align:left;"><strong>Data Parallelism</strong></td><td style="text-align:left;"><strong>Native Auto-Vectorization &amp; GPU</strong></td><td style="text-align:left;">No (Manual SIMD assembly)</td><td style="text-align:left;">Auto-vectorization (LLVM)</td><td style="text-align:left;">Manual Intrinsics</td><td style="text-align:left;"><code>std::execution</code> (C++17) / OpenMP</td></tr><tr><td style="text-align:left;"><strong>GPU Offload</strong></td><td style="text-align:left;"><strong>Automatic (SPIR-V)</strong></td><td style="text-align:left;">No (CGO + OpenCL/CUDA)</td><td style="text-align:left;">No (External Crates)</td><td style="text-align:left;">No (CUDA/OpenCL)</td><td style="text-align:left;">No (CUDA/OpenCL/SYCL)</td></tr><tr><td style="text-align:left;"><strong>Channels</strong></td><td style="text-align:left;">Native <code>Channel&lt;T&gt;</code></td><td style="text-align:left;">Native <code>chan T</code></td><td style="text-align:left;">Library (<code>std::sync::mpsc</code>)</td><td style="text-align:left;">Manual</td><td style="text-align:left;">Library</td></tr><tr><td style="text-align:left;"><strong>Select</strong></td><td style="text-align:left;"><code>select { case ... }</code></td><td style="text-align:left;"><code>select { case ... }</code></td><td style="text-align:left;">Macro <code>select!</code></td><td style="text-align:left;"><code>poll</code></td><td style="text-align:left;">N/A</td></tr></tbody></table><h2 id="key-concepts" tabindex="-1">Key Concepts <a class="header-anchor" href="#key-concepts" aria-label="Permalink to “Key Concepts”">​</a></h2><h3 id="hybrid-model-task-data-parallelism" tabindex="-1">Hybrid Model: Task + Data Parallelism <a class="header-anchor" href="#hybrid-model-task-data-parallelism" aria-label="Permalink to “Hybrid Model: Task + Data Parallelism”">​</a></h3><p>Vex distinguishes itself by treating concurrency (task management) and parallelism (data processing) as native language features, not just library add-ons.</p><ol><li><strong>Task Concurrency (Go-style):</strong> <code>go</code> routines and channels for orchestrating I/O and independent tasks.</li><li><strong>Data Parallelism (HPC):</strong> Vex&#39;s compiler and runtime automatically identify data-parallel workloads. <ul><li><strong>SIMD:</strong> Small loops are auto-vectorized for CPU (AVX2/AVX-512/NEON).</li><li><strong>SIMT (GPU):</strong> Large data operations are automatically compiled to <strong>SPIR-V</strong> and offloaded to the GPU if heuristics determine it&#39;s efficient.</li></ul></li></ol><h3 id="example-comparison" tabindex="-1">Example Comparison <a class="header-anchor" href="#example-comparison" aria-label="Permalink to “Example Comparison”">​</a></h3><p><strong>Vex (GPU Offload):</strong></p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vex - &#39;launch&#39; keyword or auto-detection handles offload</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Compiler detects large dataset + parallelizable operation</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> large_array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -&gt; Compiles to SPIR-V kernel for GPU</span></span></code></pre></div><p><strong>C++ (Manual CUDA):</strong></p><div class="language-cpp"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// C++ requires extensive Setup + Kernel writing</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">__global__ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">float*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a) { ... }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cudaMalloc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(...);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cudaMemcpy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(...);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">blocks, threads</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d_a);</span></span></code></pre></div><h3 id="concurrency-primitives" tabindex="-1">Concurrency Primitives <a class="header-anchor" href="#concurrency-primitives" aria-label="Permalink to “Concurrency Primitives”">​</a></h3><p><strong>Vex:</strong></p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">go </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ch);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ch;</span></span></code></pre></div><p><strong>Go:</strong></p><div class="language-go"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">chan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">go</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ch)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ch</span></span></code></pre></div><p><strong>Rust:</strong></p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (tx, rx) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mpsc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">channel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">thread</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">move</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tx));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">recv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unwrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div>`,19)])])}const c=t(l,[["render",n]]);export{g as __pageData,c as default};
