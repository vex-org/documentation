import{_ as e,c as d,o,aj as c}from"./chunks/framework.CSCBGoZg.js";const h=JSON.parse('{"title":"Auto-Vectorization Operator Mapping: Vex to SPIR-V","description":"","frontmatter":{},"headers":[],"relativePath":"extra/SPIRV_Mapping.md","filePath":"extra/SPIRV_Mapping.md"}'),r={name:"extra/SPIRV_Mapping.md"};function a(i,t,n,s,l,p){return o(),d("div",null,[...t[0]||(t[0]=[c('<h1 id="auto-vectorization-operator-mapping-vex-to-spir-v" tabindex="-1">Auto-Vectorization Operator Mapping: Vex to SPIR-V <a class="header-anchor" href="#auto-vectorization-operator-mapping-vex-to-spir-v" aria-label="Permalink to “Auto-Vectorization Operator Mapping: Vex to SPIR-V”">​</a></h1><p><strong>Date:</strong> December 19, 2025 <strong>Status:</strong> Verification Complete (Full Parity)</p><p>This document tracks the mapping between Vex&#39;s auto-vectorization operators and their SPIR-V implementation strategies.</p><h2 id="_1-direct-mapping-native-spir-v-instructions" tabindex="-1">1. Direct Mapping (Native SPIR-V Instructions) <a class="header-anchor" href="#_1-direct-mapping-native-spir-v-instructions" aria-label="Permalink to “1. Direct Mapping (Native SPIR-V Instructions)”">​</a></h2><table tabindex="0"><thead><tr><th>Vex Operator</th><th>Description</th><th>SPIR-V Instruction</th><th>Notes</th></tr></thead><tbody><tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></td><td>Basic Arith</td><td><code>OpIAdd</code>, <code>OpFAdd</code>, etc.</td><td>Fully supported</td></tr><tr><td><code>&amp;</code>, `</td><td><code>, </code>^<code>, </code>~`</td><td>Bitwise</td><td><code>OpBitwiseAnd</code>, <code>OpBitwiseOr</code>, <code>OpBitwiseXor</code>, <code>OpNot</code></td></tr><tr><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td><td>Shift</td><td><code>OpShiftLeftLogical</code>, <code>OpShiftRightLogical</code>, <code>OpShiftRightArithmetic</code></td><td>Fully supported</td></tr><tr><td><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code></td><td>Comparison</td><td><code>OpIEqual</code>, <code>OpFOrdEqual</code>, <code>OpSLessThan</code>, etc.</td><td>Fully supported</td></tr><tr><td><code>? :</code></td><td>Select</td><td><code>OpSelect</code></td><td>Fully supported</td></tr><tr><td><code>.popcnt()</code></td><td>Bit Count</td><td><code>OpBitCount</code></td><td>Fully supported</td></tr><tr><td><code>as</code></td><td>Cast</td><td><code>OpConvertFToS</code>, <code>OpConvertSToF</code>, <code>OpBitcast</code></td><td>Fully supported</td></tr></tbody></table><h2 id="_2-extended-instruction-mapping-glsl-std-450" tabindex="-1">2. Extended Instruction Mapping (GLSL.std.450) <a class="header-anchor" href="#_2-extended-instruction-mapping-glsl-std-450" aria-label="Permalink to “2. Extended Instruction Mapping (GLSL.std.450)”">​</a></h2><p>Requires <code>OpExtInstImport &quot;GLSL.std.450&quot;</code>.</p><table tabindex="0"><thead><tr><th>Vex Operator</th><th>Description</th><th>GLSL.std.450 Function</th><th>Implementation Strategy</th></tr></thead><tbody><tr><td><code>&lt;?</code>, <code>&gt;?</code></td><td>Min/Max</td><td><code>FMin</code>, <code>SMin</code>, <code>UMin</code>, <code>FMax</code>, <code>SMax</code>, <code>UMax</code></td><td>Map directly to extended instructions.</td></tr><tr><td><code>.abs()</code></td><td>Absolute</td><td><code>FAbs</code>, <code>SAbs</code></td><td>Map directly.</td></tr><tr><td><code>.sqrt()</code>, <code>.rsqrt()</code></td><td>Roots</td><td><code>Sqrt</code>, <code>InverseSqrt</code></td><td>Map directly.</td></tr><tr><td><code>.round()</code>, <code>.floor()</code></td><td>Rounding</td><td><code>Round</code>, <code>Floor</code>, <code>Ceil</code></td><td>Map directly.</td></tr><tr><td><code>.sin()</code>, <code>.cos()</code></td><td>Trig</td><td><code>Sin</code>, <code>Cos</code>, <code>Tan</code>, <code>Asin</code>, etc.</td><td>Map directly.</td></tr><tr><td><code>*+</code></td><td>Fused Mul-Add</td><td><code>Fma</code></td><td>Map directly.</td></tr><tr><td>`+</td><td><code>, </code>-</td><td>`</td><td>Saturating Math</td></tr></tbody></table><h2 id="_3-emulation-required-no-direct-instruction" tabindex="-1">3. Emulation Required (No Direct Instruction) <a class="header-anchor" href="#_3-emulation-required-no-direct-instruction" aria-label="Permalink to “3. Emulation Required (No Direct Instruction)”">​</a></h2><table tabindex="0"><thead><tr><th>Vex Operator</th><th>Description</th><th>Implementation Strategy</th><th>Complexity</th></tr></thead><tbody><tr><td><code>&lt;&lt;&lt;</code>, <code>&gt;&gt;&gt;</code></td><td>Rotate</td><td>`(x &lt;&lt; n)</td><td>(x &gt;&gt; (width - n))`</td></tr><tr><td><code>*^</code></td><td>Carry-less Mul</td><td>Software emulation loop (Shift-XOR)</td><td><strong>Supported</strong> - Emulated via control flow.</td></tr><tr><td><code>.shuffle()</code></td><td>Vector Shuffle</td><td><code>OpVectorShuffle</code></td><td>Native, but mask must be constant for <code>OpVectorShuffle</code>. Dynamic shuffle requires loaded usage.</td></tr></tbody></table><h2 id="_4-conclusion-strategy" tabindex="-1">4. Conclusion &amp; Strategy <a class="header-anchor" href="#_4-conclusion-strategy" aria-label="Permalink to “4. Conclusion &amp; Strategy”">​</a></h2><ol><li><strong>90% Coverage:</strong> The vast majority of Vex&#39;s proposed SIMD operators map <strong>directly</strong> to SPIR-V core or <code>GLSL.std.450</code>.</li><li><strong>Saturation:</strong> Saturating arithmetic (<code>+|</code>, <code>-|</code>) is not a single opcode but is efficiently implemented using <code>Add + Clamp</code>. The compiler will emit this sequence.</li><li><strong>Rotation:</strong> <code>&lt;&lt;&lt;</code> and <code>&gt;&gt;&gt;</code> will be emitted as the standard shift-OR sequence.</li><li><strong>Carry-less Mul:</strong> Originally a CPU-only op. Now implemented in SPIR-V via emulation loop for feature parity. <ul><li><em>Decision:</em> Supported via emulation. Performance warning may apply.</li></ul></li></ol><p><strong>Result:</strong> SPIR-V is a <strong>viable and excellent target</strong> for Vex&#39;s auto-vectorization backend.</p>',13)])])}const g=e(r,[["render",a]]);export{h as __pageData,g as default};
