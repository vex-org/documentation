import{_ as e,c as n,o as i,aj as s}from"./chunks/framework.CSCBGoZg.js";const m=JSON.parse('{"title":"Vex Language - Architecture Deep Dive","description":"","frontmatter":{},"headers":[],"relativePath":"extra/Architecture.md","filePath":"extra/Architecture.md"}'),l={name:"extra/Architecture.md"};function r(t,a,o,c,p,h){return i(),n("div",null,[...a[0]||(a[0]=[s(`<h1 id="vex-language-architecture-deep-dive" tabindex="-1">Vex Language - Architecture Deep Dive <a class="header-anchor" href="#vex-language-architecture-deep-dive" aria-label="Permalink to â€œVex Language - Architecture Deep Diveâ€">â€‹</a></h1><p><strong>Version:</strong> 0.2.0 <strong>Last Updated:</strong> KasÄ±m 9, 2025</p><p>This document provides detailed architectural information about Vex&#39;s implementation.</p><h2 id="ğŸ›ï¸-system-architecture" tabindex="-1">ğŸ›ï¸ System Architecture <a class="header-anchor" href="#ğŸ›ï¸-system-architecture" aria-label="Permalink to â€œğŸ›ï¸ System Architectureâ€">â€‹</a></h2><h3 id="compiler-architecture" tabindex="-1">Compiler Architecture <a class="header-anchor" href="#compiler-architecture" aria-label="Permalink to â€œCompiler Architectureâ€">â€‹</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>vex-cli/</span></span>
<span class="line"><span>â”œâ”€â”€ main.rs              # CLI entry point</span></span>
<span class="line"><span>â””â”€â”€ commands/            # Command implementations</span></span>
<span class="line"><span>    â”œâ”€â”€ run.rs          # File execution</span></span>
<span class="line"><span>    â”œâ”€â”€ compile.rs      # Compilation</span></span>
<span class="line"><span>    â”œâ”€â”€ format.rs       # Code formatting</span></span>
<span class="line"><span>    â””â”€â”€ pm.rs           # Package management</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vex-lexer/              # Tokenization</span></span>
<span class="line"><span>â””â”€â”€ src/lib.rs          # Logos-based lexer</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vex-parser/             # Syntax Analysis</span></span>
<span class="line"><span>â”œâ”€â”€ src/</span></span>
<span class="line"><span>â”‚   â”œâ”€â”€ lib.rs          # Public API</span></span>
<span class="line"><span>â”‚   â””â”€â”€ parser/         # Parser modules</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vex-ast/                # Abstract Syntax Tree</span></span>
<span class="line"><span>â””â”€â”€ src/lib.rs          # AST definitions</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vex-compiler/           # Code Generation</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vex-runtime/            # C Runtime</span></span>
<span class="line"><span>â”œâ”€â”€ c/                  # C implementation</span></span>
<span class="line"><span>â””â”€â”€ src/                # Rust FFI bindings</span></span></code></pre></div><h3 id="data-flow" tabindex="-1">Data Flow <a class="header-anchor" href="#data-flow" aria-label="Permalink to â€œData Flowâ€">â€‹</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Source Code (.vx)</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>    Tokenization</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>   Syntax Parsing</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>  Abstract Syntax Tree</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>   Borrow Checking</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>   Type Checking</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>   LLVM IR Generation</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>   Optimization</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>   Machine Code</span></span>
<span class="line"><span>       â†“</span></span>
<span class="line"><span>   Executable Binary</span></span></code></pre></div><h2 id="ğŸ”-detailed-component-analysis" tabindex="-1">ğŸ” Detailed Component Analysis <a class="header-anchor" href="#ğŸ”-detailed-component-analysis" aria-label="Permalink to â€œğŸ” Detailed Component Analysisâ€">â€‹</a></h2><h3 id="span-tracking-system" tabindex="-1">Span Tracking System <a class="header-anchor" href="#span-tracking-system" aria-label="Permalink to â€œSpan Tracking Systemâ€">â€‹</a></h3><p>The compiler maintains precise source location tracking for accurate diagnostics:</p><h4 id="span-recording-parser-layer" tabindex="-1">Span Recording (Parser Layer) <a class="header-anchor" href="#span-recording-parser-layer" aria-label="Permalink to â€œSpan Recording (Parser Layer)â€">â€‹</a></h4><ul><li>Every AST node has an optional <code>span_id: Option&lt;String&gt;</code> field</li><li>Parser records span IDs via <code>span_map.generate_id()</code> during tokenization</li><li>SpanMap stores mappings from span IDs to (file, line, column, length)</li><li>Spans are serialization-skipped (<code>#[serde(skip)]</code>) to avoid overhead</li></ul><h4 id="span-preservation-compiler-layer" tabindex="-1">Span Preservation (Compiler Layer) <a class="header-anchor" href="#span-preservation-compiler-layer" aria-label="Permalink to â€œSpan Preservation (Compiler Layer)â€">â€‹</a></h4><ul><li>Generic substitution preserves span_id during type instantiation</li><li>Closure generation extracts spans from expression bodies</li><li>All compiler phases maintain span information through transformations</li></ul><h4 id="span-resolution-diagnostics-layer" tabindex="-1">Span Resolution (Diagnostics Layer) <a class="header-anchor" href="#span-resolution-diagnostics-layer" aria-label="Permalink to â€œSpan Resolution (Diagnostics Layer)â€">â€‹</a></h4><ul><li>Borrow checker diagnostics resolve spans via <code>span_map.get(span_id)</code></li><li>Linter rules (dead_code, naming_convention, unreachable_code, unused_variables) use span_map</li><li>Fallback to <code>Span::unknown()</code> only when span unavailable (edge cases)</li><li>All critical diagnostic paths use actual source locations</li></ul><p><strong>Implementation Status:</strong> âœ… Complete</p><ul><li>0 <code>span_id: None</code> usages</li><li>31 <code>Span::unknown()</code> usages (20 legitimate fallbacks, 9 edge cases, 2 tests)</li><li>All major diagnostics span-aware</li></ul><h3 id="borrow-checker-architecture" tabindex="-1">Borrow Checker Architecture <a class="header-anchor" href="#borrow-checker-architecture" aria-label="Permalink to â€œBorrow Checker Architectureâ€">â€‹</a></h3><p>The borrow checker implements a 4-phase analysis:</p><h4 id="phase-1-immutability-analysis" tabindex="-1">Phase 1: Immutability Analysis <a class="header-anchor" href="#phase-1-immutability-analysis" aria-label="Permalink to â€œPhase 1: Immutability Analysisâ€">â€‹</a></h4><ul><li>Enforces <code>let</code> vs <code>let!</code> semantics</li><li>Tracks variable mutability throughout scope</li><li>Prevents immutable variable mutations</li></ul><h4 id="phase-2-move-semantics" tabindex="-1">Phase 2: Move Semantics <a class="header-anchor" href="#phase-2-move-semantics" aria-label="Permalink to â€œPhase 2: Move Semanticsâ€">â€‹</a></h4><ul><li>Prevents use-after-move violations</li><li>Tracks value ownership transfers</li><li>Implements ownership semantics</li></ul><h4 id="phase-3-borrow-rules" tabindex="-1">Phase 3: Borrow Rules <a class="header-anchor" href="#phase-3-borrow-rules" aria-label="Permalink to â€œPhase 3: Borrow Rulesâ€">â€‹</a></h4><ul><li>Enforces reference aliasing rules</li><li>Prevents mutable/immutable reference conflicts</li><li>Validates reference lifetimes within functions</li></ul><h4 id="phase-4-lifetime-analysis" tabindex="-1">Phase 4: Lifetime Analysis <a class="header-anchor" href="#phase-4-lifetime-analysis" aria-label="Permalink to â€œPhase 4: Lifetime Analysisâ€">â€‹</a></h4><ul><li>Tracks reference validity across scopes</li><li>Prevents dangling references</li><li>Validates complex lifetime relationships</li></ul><h3 id="code-generation-strategy" tabindex="-1">Code Generation Strategy <a class="header-anchor" href="#code-generation-strategy" aria-label="Permalink to â€œCode Generation Strategyâ€">â€‹</a></h3><h4 id="ast-visitor-pattern" tabindex="-1">AST Visitor Pattern <a class="header-anchor" href="#ast-visitor-pattern" aria-label="Permalink to â€œAST Visitor Patternâ€">â€‹</a></h4><ul><li><code>ASTCodeGen</code> trait for node traversal</li><li>Separate compilation for each AST node type</li><li>Modular codegen architecture</li></ul><h4 id="type-system-integration" tabindex="-1">Type System Integration <a class="header-anchor" href="#type-system-integration" aria-label="Permalink to â€œType System Integrationâ€">â€‹</a></h4><ul><li>LLVM type mapping for Vex types</li><li>Generic instantiation support</li><li>Trait method resolution</li></ul><h4 id="memory-management" tabindex="-1">Memory Management <a class="header-anchor" href="#memory-management" aria-label="Permalink to â€œMemory Managementâ€">â€‹</a></h4><ul><li>Stack allocation for locals</li><li>Heap allocation for collections</li><li>Automatic cleanup via ownership</li></ul><h3 id="runtime-architecture" tabindex="-1">Runtime Architecture <a class="header-anchor" href="#runtime-architecture" aria-label="Permalink to â€œRuntime Architectureâ€">â€‹</a></h3><h4 id="c-runtime-design" tabindex="-1">C Runtime Design <a class="header-anchor" href="#c-runtime-design" aria-label="Permalink to â€œC Runtime Designâ€">â€‹</a></h4><ul><li>High-performance C implementation</li><li>SIMD-optimized operations</li><li>Lock-free data structures</li></ul><h4 id="async-runtime" tabindex="-1">Async Runtime <a class="header-anchor" href="#async-runtime" aria-label="Permalink to â€œAsync Runtimeâ€">â€‹</a></h4><ul><li>Event-driven architecture</li><li>Goroutine scheduling</li><li>Channel-based communication</li></ul><h4 id="memory-allocator" tabindex="-1">Memory Allocator <a class="header-anchor" href="#memory-allocator" aria-label="Permalink to â€œMemory Allocatorâ€">â€‹</a></h4><ul><li>Custom allocator for Vex types</li><li>Size-class based allocation</li><li>Efficient deallocation</li></ul><h2 id="ğŸ“Š-performance-characteristics" tabindex="-1">ğŸ“Š Performance Characteristics <a class="header-anchor" href="#ğŸ“Š-performance-characteristics" aria-label="Permalink to â€œğŸ“Š Performance Characteristicsâ€">â€‹</a></h2><h3 id="compilation-speed" tabindex="-1">Compilation Speed <a class="header-anchor" href="#compilation-speed" aria-label="Permalink to â€œCompilation Speedâ€">â€‹</a></h3><ul><li>Fast incremental compilation</li><li>Efficient LLVM optimization</li><li>Minimal memory usage</li></ul><h3 id="runtime-performance" tabindex="-1">Runtime Performance <a class="header-anchor" href="#runtime-performance" aria-label="Permalink to â€œRuntime Performanceâ€">â€‹</a></h3><ul><li>Zero-cost abstractions</li><li>SIMD acceleration</li><li>Efficient memory management</li></ul><h3 id="memory-usage" tabindex="-1">Memory Usage <a class="header-anchor" href="#memory-usage" aria-label="Permalink to â€œMemory Usageâ€">â€‹</a></h3><ul><li>Minimal runtime overhead</li><li>Stack-based locals</li><li>Efficient heap allocation</li></ul><h2 id="ğŸ”§-development-workflow" tabindex="-1">ğŸ”§ Development Workflow <a class="header-anchor" href="#ğŸ”§-development-workflow" aria-label="Permalink to â€œğŸ”§ Development Workflowâ€">â€‹</a></h2><h3 id="code-organization" tabindex="-1">Code Organization <a class="header-anchor" href="#code-organization" aria-label="Permalink to â€œCode Organizationâ€">â€‹</a></h3><ul><li>Modular crate structure</li><li>Clear separation of concerns</li><li>Comprehensive testing</li></ul><h3 id="quality-assurance" tabindex="-1">Quality Assurance <a class="header-anchor" href="#quality-assurance" aria-label="Permalink to â€œQuality Assuranceâ€">â€‹</a></h3><ul><li>100% test coverage target</li><li>Static analysis tools</li><li>Performance benchmarking</li></ul><h3 id="continuous-integration" tabindex="-1">Continuous Integration <a class="header-anchor" href="#continuous-integration" aria-label="Permalink to â€œContinuous Integrationâ€">â€‹</a></h3><ul><li>Automated testing</li><li>Documentation updates</li><li>Release automation</li></ul><hr><p><em>This file is automatically updated by scripts/update_docs.sh</em></p>`,59)])])}const u=e(l,[["render",r]]);export{m as __pageData,u as default};
